#!/usr/bin/env ksh
#
############################################################################
#
# Name:		mailatt
# Version:	1.18.6
# Created:	2011-02-11
# Date:		2019-03-29
# Author:	Rene Uittenbogaard
# Requires:	sendmail
# Usage:	mailatt [ -Iai ] [ -Vd ] [ -r <recipient> ] [ -c <cc-addr> ]
#			[ -b <bcc-addr> ] [ -f <from> ] [ -R <reply-to> ]
#			[ -s <subject> ] [ -H <headerline> ]
#			[ -C <charset> ] [ -M mimetype ] [ -8mqu ]
#			[ <file1> .. <filen> ]
#		mailatt { -h | -v }
#
# TODO:		test: unfolded header lines
#		test: fold lines 'testing a very long subject line to see if
#		everything works out fine for this type of encoding' | fmt -w80
#		feat: implement multipart/related using content-id?
#		feat: Content-MD5 header?
#

# The main program code starts at the label '# main'

############################################################################
# version info for *roff

version='

=pod

=for roff
.ds Yr 2011-2019
.ds Vw @(#) mailatt 1.18.6
.de Vp
This manual pertains to \fBmailatt\fP version \\$3.
..
.hy 0 \" hyphenation off \

=cut '

############################################################################
# functions

f_initialize() {
	f_setpath
	f_findawk
	f_select_encoder init
	f_find_cid_data
	#source mime-identify ''
	attno=0
	charset=us-ascii
	mixed_or_alternative=mixed
	inline_or_attachment=attachment
}

f_setpath() {
	# SunOS 5.7 has sendmail installed in /usr/lib
	# SunOS 5.8 has a broken /usr/ucb/echo, don't put it in front!
	PATH=/usr/sbin:$PATH:/usr/ucb:/usr/ccs/bin:/usr/xpg4/bin:/usr/local/bin:/usr/lib
}

f_findawk() {
	if f_has gawk; then
		awk=gawk
	elif [ -x /usr/xpg4/bin/awk ]; then
		awk=/usr/xpg4/bin/awk
	elif f_has mawk; then
		awk=mawk
	elif f_has nawk; then
		awk=nawk
	else
		awk=awk
	fi
}

f_echo() {
	printf "%b\n" "$*"
}

f_echon() {
	printf "%b" "$*"
}

f_usage() {
	f_echo "Usage: $argv0\t[ -Iai ] [ -Vd ] [ -r <recipient> ] [ -c <cc-addr> ]"
	f_echo "\t\t[ -b <bcc-addr> ] [ -f <from> ] [ -R <reply-to> ]"
	f_echo "\t\t[ -s <subject> ] [ -H <headerline> ] [ -8mqu ]"
	f_echo "\t\t[ -C <charset> ] [ -M <mime-type> ] [ <file1> .. <filen> ]"
	f_echo "       $argv0\t{ -h | -v }"
}

f_version() {
	f_echo "$version" | $awk '/@[(]#[)]/ { sub(".*@[(]#[)] ?", ""); print }'
}

f_getusername() {
	# find name from password file (GCOS field) or NIS
	{
		# Is NIS active? Then give it preference over local passwd
		if f_has domainname && test "`domainname 2>/dev/null`"; then
			ypmatch "$1" passwd 2>/dev/null
		fi
		# Always consult local passwd
		cat /etc/passwd
	} | $awk -F: '$1 == "'"$1"'" { sub(/,.*/, "", $5); print $5 }'
}

f_notify_interactive() {
	test -t 0 && f_echo "Reading document from stdin..." 1>&2
}

f_lowercase() {
	# tr '[:upper:]' '[:lower:]' # needs LC_CTYPE to function correctly
	f_echo "$@" | tr A-Z a-z
}

f_has() {
	# The built-in "which" does not always set $? correctly and cannot always be silenced.
	# This function is completely silent.
	# This tr(1) invocation is safe because directories in PATH cannot contain colons.
	for i in $(echo $PATH | tr : " "); do
		test -x "$i/$1" 2>/dev/null && return 0
	done
	return 1
}

f_find_cid_data() {
	cidtime="$(date +"%Y%m%d%H%M%S")"
	cidrandom="`f_boundbits`"
	cidhost="$(hostname)" 2>/dev/null
}

#
# Find the numeric mode for a file
# @param {string} filename
#
f_mode() {
	ls -lLd "$1" | $awk '
		BEGIN { mode = 0 }
		$1 ~ /^.r......../ { mode += 400  }
		$1 ~ /^..w......./ { mode += 200  }
		$1 ~ /^...x....../ { mode += 100  }
		$1 ~ /^...s....../ { mode += 4100 }
		$1 ~ /^...S....../ { mode += 4000 }
		$1 ~ /^....r...../ { mode += 40   }
		$1 ~ /^.....w..../ { mode += 20   }
		$1 ~ /^......x.../ { mode += 10   }
		$1 ~ /^......s.../ { mode += 2010 }
		$1 ~ /^......S.../ { mode += 2000 }
		$1 ~ /^......l.../ { mode += 2000 } # Solaris
		$1 ~ /^.......r../ { mode += 4    }
		$1 ~ /^........w./ { mode += 2    }
		$1 ~ /^.........x/ { mode += 1    }
		$1 ~ /^.........t/ { mode += 1001 }
		$1 ~ /^.........T/ { mode += 1000 }
		END { print mode }
	'
}

f_onlcr() {
	$awk '{
		sub(/\015$/, "")
		printf("%s\r\n", $0)
	}'
}

f_encode_header() {
	if [ "$(f_lowercase $charset)" = us-ascii ]; then
		f_echo "$1"
	else
		indent=
		f_echon "$1" | f_dissect | f_adjust_linelen 330 | $awk 'NF > 1 { print }' | while read header_line;
		do
			encoded="$(f_echon "$header_line" | $header_encoder 1)"
			f_echo "${indent}=?${charset}?${header_encoding}?${encoded}?="
			indent='\t'
		done
	fi
}

f_add_address() {
	# allowed values for $addr:
	#    user
	#    <user>
	#    <user@domain>
	#    name <user>
	#    name <user@domain>
	# test whether $addr is of the form user <user@dom>
	if [ "${addr##*<}" != "$addr" ]; then
		# split into 'name' and 'user[@domain]' parts
		fullname="${addr%<*}"
		while [ "${fullname% }" != "$fullname" ]; do
			fullname="${fullname% }"
		done
		addr="${addr##*<}"
		addr="${addr%>}"
	else
		fullname=
	fi
	if [ "${addr#*@}" = "$addr" -a -z "$fullname" ]; then
		fullname="$(f_getusername "$addr")"
	fi
	addressline="${addressline:+$addressline, }${fullname:+$(f_encode_header "$fullname") }<$addr>"
}

f_add_addresses() {
	optarg="$1"
	addressline=
	if   [ "$currentopt" = r ]; then
		to="To:"
	elif [ "$currentopt" = c ]; then
		to="Cc:"
	elif [ "$currentopt" = b ]; then
		to="Bcc:"
	elif [ "$currentopt" = R ]; then
		to="Reply-To:"
	else
		to="From:"
		optarg="${optarg%%,*}"
	fi
	while [ "${optarg#*,}" != "$optarg" ]; do
		addr="${optarg%%,*}"
		optarg="${optarg#*,}"
		f_add_address
	done
	addr="$optarg"
	f_add_address
	if [ "$currentopt" = f ]; then
		envelope_from="-f $addr"
	fi
	addresses="$to $addressline${addresses:+\\n$addresses}"
}

#
# Not all systems have mmencode(1); therefore, we'll encode it here
#
# @param {int} whether we are encoding a mime part (0) or header field (1)
#
f_base64encode_bytes() {
	# Tested on:
	#    HP-UX 10.20
	#    HP-UX 11.11
	#    AIX 4.2
	#    SunOS 5.8
	#    SunOS 5.11
	#    SuSE UnitedLinux 1.0
	#    Debian 3.0
	#    Darwin 17.7.0
	$awk -v inheader="$1" '
		# encode file to base64
		# remotely based on a script by Peter van Eerten (c) March 6 2003
		# note: the number of bytes on each line MUST be a multiple of 3
		#
		function store(n) {
			buffer[bufindex++] = n
			if (bufindex > 3) {
				spout(buffer[1], buffer[2], buffer[3])
				bufindex = 1
			}
		}
		function flush() {
			if (bufindex >= 2) {
				if (bufindex == 2) buffer[2] = 0
				spout(buffer[1], buffer[2], 0)
			}
			if (!inheader) printf("\n")
		}
		function spout(byte1, byte2, byte3) {
			# Create base64 values
			base1 = int(byte1 / 4)
			base2 = ((byte1 %  4) * 16) + int(byte2 / 16)
			base3 = ((byte2 % 16) *  4) + int(byte3 / 64)
			base4 = (byte3 % 64)
			# Compose string
			if (bufindex == 2) result = pick(base1) pick(base2) "=="
			if (bufindex == 3) result = pick(base1) pick(base2) pick(base3) "="
			if (bufindex  > 3) result = pick(base1) pick(base2) pick(base3) pick(base4)
			printf("%s", result)
		}
		function pick(num) {
			return substr(set, num + 1, 1)
		}
		BEGIN {
			bufindex = 1
			set = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
		}
		NF > 1 {
			for (i = 2; i <= NF; i++) store($i)
			flush()
		}
	'
}

#
# not all systems have uuencode(1); therefore, we'll encode it here
#
f_uuencode_bytes() {
	# Tested on:
	#    SunOS 5.11
	#    Darwin 17.7.0
	$awk '
		# uuencode file
		# note: the number of bytes on each line MUST be a multiple of 3
		#
		function store(n) {
			buffer[bufindex++] = n
			if (bufindex > 3) {
				spout(buffer[1], buffer[2], buffer[3])
				bufindex = 1
			}
		}
		function flush() {
			if (bufindex >= 2) {
				if (bufindex == 2) buffer[2] = 0
				spout(buffer[1], buffer[2], 0)
			}
			printf("\n")
		}
		function spout(byte1, byte2, byte3) {
			# Create base64 values
			base1 = int(byte1 / 4)
			base2 = ((byte1 %  4) * 16) + int(byte2 / 16)
			base3 = ((byte2 % 16) *  4) + int(byte3 / 64)
			base4 = (byte3 % 64)
			# Compose string
			if (bufindex == 2) result = pick(base1) pick(base2) "=="
			if (bufindex == 3) result = pick(base1) pick(base2) pick(base3) "="
			if (bufindex  > 3) result = pick(base1) pick(base2) pick(base3) pick(base4)
			printf("%s", result)
		}
		function pick(num) {
			return substr(cset, num + 1, 1)
		}
		function len(num) {
			return substr(lset, num + 1, 1)
		}
		BEGIN {
			bufindex = 1
			# here, we need to escape the double quote, the single quote, and the backslash
			cset = " !\"#$%&'\''()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`"
			lset = "`!\"#$%&'\''()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_"
		}
		NF > 1 {
			printf(len(NF - 1))
			for (i = 2; i <= NF; i++) store($i)
			flush()
		}
	'
}

#
# QP-encode the output of the hexdump/octal dump.
#
# @param {int} whether we are encoding a mime part (0) or header field (1)
# @param {int} whether we want compact (0) or readable, linewise encoding (1)
#
f_qpencode_bytes() {
	# Tested on:
	#    HP-UX 10.20
	#    HP-UX 11.11
	#    AIX 4.2
	#    SunOS 5.8
	#    SunOS 5.11
	#    SuSE UnitedLinux 1.0
	#    Debian 3.0
	#    Darwin 17.7.0
	$awk -v inheader="$1" -v linewise="$2" '
		NF > 1 {
			if (NR > 1) printf("%s", (inheader ? "\n  " : "=\n"))
			for (i = 2; i <= NF; i++) {
				# test if normal ascii, but not full stop (46)
				# (causes errors at start of line) or equals sign (61)
				#
				if (($i > 32) && ($i != 46) && ($i != 61) && ($i < 127))   printf("%c", $i)
				# space
				else if (($i == 32) && (!inheader) && (i > 2) && (i < NF)) printf(" ")
				# newline
				else if (($i == 10) && (!inheader) && linewise)            printf("=0A=\n")
				else                                                       printf("=%02X", $i)
			}
		}
		END {
			if (!inheader) printf("\n")
		}
	'
}

f_base64encode_file() {
	# number of fields MUST be a multiple of 3
	f_dissect ${1:+"$1"} | f_adjust_linelen 54 | f_base64encode_bytes 0
}

f_uuencode_file() {
	f_echo "begin $(f_mode ${1:-/}) $(basename ${1:-stdin})"
	# number of fields MUST be a multiple of 3
	f_dissect ${1:+"$1"} | f_adjust_linelen 45 | f_uuencode_bytes 0
	f_echo "\`\nend"
}

f_qpencode_file() {
	f_dissect ${1:+"$1"} | f_adjust_linelen 23 | f_qpencode_bytes 0
}

f_qpencode_file_linewise() {
	f_dissect ${1:+"$1"} | f_adjust_linelen 72 | f_qpencode_bytes 0 1
}

#
# Extend the hexdump/octal dump output to contain a certain number of fields
# per line. This will correspond to the number of characters per line after
# encoding.
#
# @param {int} new number of byte fields per line, not counting the first
# ('offset') field
#
f_adjust_linelen() {
	$awk -v maxfields="${1:-18}" '
		BEGIN {
			r = 0
			# the first field is not accurate any more,
			# but it is discarded by f_*encode_line anyway
			printf("0000000")
		}
		{
			for (i = 2; i <= NF; i++) {
				printf(" %3d", $i)
				if (++r >= maxfields) {
					r = 0
					printf("\n%s", "0000000")
				}
			}
		}
		END {
			printf("\n")
		}
	'
}

#
# Print the contents of the file, byte by byte.
# The first field on each line is the byte offset, the rest are the actual bytes
#
# Example output:
#
# 0000000   137  80  78  71  13  10  26  10   0   0   0  13  73  72  68  82
# 0000020     0   0   0  16   0   0   0  16   8   6   0   0   0  31 243 255
# 0000040    97   0   0   0   4 103  65  77  65   0   0 177 142 124 251  81
#
# @param {string} input filename, or - to read from stdin
#
f_dissect() {
	# some platforms don't have od(1)
	if [ `uname` = FreeBSD -o `uname` = Darwin ]; then
		if [ "x$1" == x- ]; then
			# Read from stdin. Not all versions of hexdump(1)
			# support '-' as a shorthand for stdin.
			arg=
		else
			arg="$1"
		fi
		hexdump -v -e '"%06.6_ao " 16/1 "%3u " "\n"' ${arg:+"$arg"}
	else
		od -t u1 -v ${1:+"$1"}
	fi
}

f_select_encoder() {
	case "$1" in
		u)	bin_encoding=uuencode
			bin_encoder=f_uuencode_file
			asc_encoding=uuencode
			asc_encoder=f_uuencode_file
			header_encoding=B
			header_encoder=f_base64encode_bytes
			;;
		m)	bin_encoding=base64
			bin_encoder=f_base64encode_file
			asc_encoding=base64
			asc_encoder=f_base64encode_file
			header_encoding=B
			header_encoder=f_base64encode_bytes
			;;
		q)	bin_encoding=quoted-printable
			bin_encoder=f_qpencode_file
			asc_encoding=quoted-printable
			asc_encoder=f_qpencode_file_linewise
			header_encoding=Q
			header_encoder=f_qpencode_bytes
			;;
		8)	bin_encoding=8bit
			bin_encoder=cat
			asc_encoding=8bit
			asc_encoder=cat
			header_encoding=B
			header_encoder=f_base64encode_bytes
			;;
		init)	bin_encoding=base64
			bin_encoder=f_base64encode_file
			asc_encoding=quoted-printable
			asc_encoder=f_qpencode_file_linewise
			header_encoding=B
			header_encoder=f_base64encode_bytes
			;;
		*)	bin_encoding=binary
			bin_encoder=cat
			asc_encoding=binary
			asc_encoder=cat
			header_encoding=B
			header_encoder=f_base64encode_bytes
			;;
	esac
}

f_boundbits() {
	echo "$RANDOM $RANDOM * $RANDOM * $$ * 63o p" | dc | $awk 'BEGIN {
		set="0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz_";
	}
	{
		for (i=1;i<=NF;i++) {
			printf(substr(set, $i+1, 1));
		}
	}
	END {
		print "";
	}'
}

f_startmail() {
	test "$addresses"   && f_echo "$addresses"
	test "$subject"     && f_echo "$subject"
	test "$headerlines" && f_echo "$headerlines"
	boundary="Mailatt=Part:$RANDOM.$(f_boundbits)+$(f_boundbits)/"
	cat <<-_MIME_header_preamble_
		MIME-Version: 1.0
		Content-Type: multipart/$mixed_or_alternative; boundary="$boundary"
		X-Mailer: $(f_version)
		
		This is a multipart message in MIME format.
		If your mail reader displays this preamble, it does not support MIME.
		
	_MIME_header_preamble_
}

f_endmail() {
	f_echo "--$boundary--"
}

f_sendmail() {
	f_onlcr | if [ -n "${MAILATT_DEBUG#0}" ]; then
		cat
	else
		sendmail -t -i $envelope_from
	fi
}

f_contentid() {
	f_echo "$cidtime.$cidrandom.$attno.${fname}@$cidhost" | sed 's/>/_/g'
}

f_composemail() {
	f_startmail
	f_process_all_files "$@"
	f_endmail
}

f_binattach() {
	f_echo "Content-Transfer-Encoding: $bin_encoding"
	f_echo
	$bin_encoder "$1"
}

f_ascattach() {
	f_echo "Content-Transfer-Encoding: $asc_encoding"
	f_echo
	$asc_encoder "$1"
}

f_msgattach() {
	# RFC 2045 states: it is EXPRESSLY FORBIDDEN to use any encodings
	# other than "7bit", "8bit", or "binary" with any composite media type,
	# i.e. one that recursively includes other Content-Type fields.
	# Currently the only composite media types are "multipart" and "message". 
	#
	f_echo "Content-Transfer-Encoding: 8bit"
	f_echo
	cat "$1"
}

f_attachit() {
	let attno=attno+1
	if [ -n "$specify_inline_filename" -o "$inline_or_attachment" = attachment ]; then
		namespec="; name=\"$neatname\""
		fnamespec="; name=\"$neatname\""
	else
		namespec=
		fnamespec=
	fi
	test -n "$verbose" && f_echo "Attaching $fname..." >&2
	f_echo "--$boundary"
	f_echo "Content-ID: <$(f_contentid "$fname")>"
	f_echo "Content-Disposition: $inline_or_attachment$fnamespec"
	if [ "${contenttype%%/*}" == message   \
	-o   "${contenttype%%/*}" == multipart ];
	then
		f_echo "Content-Type: $contenttype; charset=\"$charset\"$namespec"
		f_msgattach "$fname" "$neatname"
	elif [ "$ascbin" == a ]; then
		f_echo "Content-Type: $contenttype; charset=\"$charset\"$namespec"
		f_ascattach "$fname" "$neatname"
	else # [ $ascbin == b ]
		f_echo "Content-Type: $contenttype$namespec"
		f_binattach "$fname" "$neatname"
	fi
}

f_attachment() { # {a|b} mimetype
	ascbin="$1"
	contenttype="$2"
	if [ "$contenttype" = default ]; then
		if [ "$inline_or_attachment" = inline ]; then
			contenttype=text/plain
			ascbin=a
		else
			contenttype=application/octet-stream
		fi
	fi
	if [ "x$fname" = x- ]; then
		f_notify_interactive
		neatname=stdin
	elif [ ! -r "$fname" ]; then
		f_echo "$argv0: Cannot attach \"$fname\": file not readable" >&2
		f_echon "Send mail anyway? (y/n) [n] " >&2
		read ans < /dev/tty
		if [ "${ans#n}" != "$ans" -o -z "$ans" ]; then
			exit 2
		else
			return
		fi
	else
		neatname="$(basename "$fname")"
	fi
	f_attachit
}

f_process_all_files() {
	for opt in "$@"; do
		# process options, if the end of the options has not been flagged
		if [ -z "${end_opts#0}" ]; then
			if [ -n "$charset_coming_up" ]; then
				charset="$opt"
				charset_coming_up=
				continue
			elif [ "x${opt#-C}" != "x$opt" ]; then
				charset="${opt#-C}"
				if [ -z "$charset" ]; then
					charset_coming_up=1
				fi
				continue
			elif [ -n "$mimetype_coming_up" ]; then
				mimetype="$opt"
				mimetype_coming_up=
				continue
			elif [ "x${opt#-M}" != "x$opt" ]; then
				mimetype="${opt#-M}"
				if [ -z "$mimetype" ]; then
					mimetype_coming_up=1
				fi
				continue
			elif [ "x${opt#-[muq8]}" != "x$opt" ]; then
				f_select_encoder ${opt#-}
				continue
			elif [ "x$opt" = x-- ]; then
				end_opts=1
				continue
			fi
		fi

		# process file
		f_process_one_file "$opt" $mimetype
		mimetype=

		# switch content-disposition for all following files
		# from inline to attachment if multipart/mixed,
		# but not for multipart/alternative
		if [ "$mixed_or_alternative" != alternative ]; then
			inline_or_attachment=attachment
		fi
	done
}

f_process_one_file() {
	fname="$1"
	mimetype="$2" # explicit mimetype requested?
	if [ "${mimetype%%/*}" == text ]; then
		f_attachment a "$mimetype"
		return
	elif [ -n "$mimetype" ]; then
		f_attachment b "$mimetype"
		return
	fi
	if [ "x$fname" = x- ]; then
		f_attachment a text/plain
	else
		f_attachment $(f_mime_identify "$fname")
	fi
}

############################################################################
# mime lookup table

f_mime_identify() {
	filename="$1"
	case "$(echo ${filename##*.} | tr A-Z a-z)" in
		1m)		echo a text/nroff				;;
		3gp)		echo b video/3gpp				;;
		3i)		echo a application/x-intercal			;;
		3pm)		echo a text/nroff				;;
		7z)		echo b application/x-7z-compressed		;;
		[1-8])		echo a text/nroff				;;
		a)		echo b application/x-unix-archive		;;
		a[0-9][0-9])	echo b application/arj				;;
		ac)		echo a text/x-autoconf				;;
		ai)		echo b application/postscript			;;
		aif)		echo b audio/x-aiff				;;
		aifc)		echo b audio/x-aiff				;;
		aiff)		echo b audio/x-aiff				;;
		am)		echo a text/x-autoconf				;;
		apk)		echo b application/vnd.android.package-archive	;;
		ar)		echo b application/x-unix-archive		;;
		arc)		echo b application/x-arc			;;
		arj)		echo b application/arj				;;
		asf)		echo b video/x-ms-asf				;;
		asr)		echo b video/x-ms-asf				;;
		asx)		echo b video/x-ms-asf				;;
		au)		echo b audio/basic				;;
		avi)		echo b video/x-msvideo				;;
		awk)		echo a text/x-awk				;;
		bas)		echo a text/x-bas				;;
		bash)		echo a text/x-bash				;;
		bat)		echo a text/x-msdos-batch			;;
		bf)		echo a application/x-befunge			;;
		bin)		echo b application/octet-stream			;;
		bmp)		echo b image/bmp				;;
		bz)		echo b application/x-bzip			;;
		bz2)		echo b application/x-bzip2			;;
		c)		echo a text/x-c					;;
		c++)		echo a text/x-c++				;;
		cab)		echo b application/x-cab-compressed		;;
		cc)		echo a text/x-c++				;;
		cer) 		echo a application/x-x509-ca-cert		;;
		class)		echo b application/octet-stream			;;
		cmd)		echo a text/x-msdos-batch			;;
		com)		echo b application/octet-stream			;;
		cpio)		echo b application/x-cpio			;;
		cpp)		echo a text/x-c++				;;
		crt) 		echo a application/x-x509-ca-cert		;;
		cs)		echo a text/x-csharp				;;
		csh)		echo a text/x-csh				;;
		css)		echo a text/css					;;
		deb)		echo b application/x-deb			;;
		der) 		echo a application/x-x509-ca-cert		;;
		dia)		echo b application/x-dia-diagram		;;
		dll)		echo b application/octet-stream			;;
		doc)		echo b application/msword			;;
		docx)		echo b application/msword			;;
		dot)		echo b application/msword			;;
		dvi)		echo b application/x-dvi			;;
		elm)		echo a application/x-elm			;;
		eml)		echo a message/rfc822				;;
		eot)		echo b application/vnd.ms-fontobject		;;
		eps)		echo b application/postscript			;;
		epub)		echo b application/epub+zip			;;
		exe)		echo b application/octet-stream			;;
		f)		echo a text/x-fortran				;;
		f4v)		echo b video/x-f4v				;;
		f77)		echo a text/x-fortran				;;
		f90)		echo a text/x-fortran				;;
		f95)		echo a text/x-fortran				;;
		flac)		echo b video/x-flac				;;
		flc)		echo b video/x-flac				;;
		fli)		echo b video/x-fli				;;
		flv)		echo b video/x-flv				;;
		for)		echo a text/x-fortran				;;
		gif)		echo b image/gif				;;
		gz)		echo b application/x-gzip			;;
		h)		echo a text/x-c					;;
		hh)		echo a text/plain				;;
		hlp)		echo b application/x-winhelp			;;
		hqx)		echo b application/mac-binhex40			;;
		htm)		echo a text/html				;;
		html)		echo a text/html				;;
		i)		echo a application/x-intercal			;;
		ico)		echo b image/x-icon				;;
		iges)		echo b model/ige				;;
		igs)		echo b model/ige				;;
		in)		echo a text/x-autoconf				;;
		ini)		echo a text/plain				;;
		jar)		echo b application/java-archive			;;
		java)		echo a text/x-java				;;
		jfif)		echo b image/jpeg				;;
		jpe)		echo b image/jpeg				;;
		jpeg)		echo b image/jpeg				;;
		jpg)		echo b image/jpeg				;;
		jpm)		echo b image/jpm				;;
		js)		echo a application/javascript			;;
		json)		echo a application/json				;;
		ksh)		echo a text/x-ksh				;;
		latex)		echo a application/x-latex			;;
		lha)		echo b application/x-lzh-compressed		;;
		log)		echo a text/plain				;;
		lsp)		echo a application/x-lisp			;;
		lzh)		echo b application/x-lzh-compressed		;;
		m1v)		echo b video/mpeg				;;
		m2a)		echo b audio/mpeg				;;
		m2v)		echo b video/mpeg				;;
		m3a)		echo b audio/mpeg				;;
		m3u)		echo b audio/x-mpegurl				;;
		m3u8)		echo b application/vnd.apple.mpegurl		;;
		m4a)		echo b audio/mp4				;;
		m4v)		echo b video/x-m4v				;;
		man)		echo a text/troff				;;
		md)		echo a text/markdown				;;
		mdb)		echo b application/x-msaccess			;;
		me)		echo a text/troff				;;
		mesh)		echo b model/mesh				;;
		mht)		echo a message/rfc822				;;
		mhtm)		echo a message/rfc822				;;
		mhtml)		echo a message/rfc822				;;
		mid)		echo b audio/midi				;;
		midi)		echo b audio/midi				;;
		mjs)		echo a application/javascript			;;
		mk3d)		echo b video/x-matroska				;;
		mka)		echo b audio/x-matroska				;;
		mks)		echo b video/x-matroska				;;
		mkv)		echo b video/x-matroska				;;
		mm)		echo a text/troff				;;
		mng)		echo b video/x-mng				;;
		mov)		echo b video/quicktime				;;
		movie)		echo b video/x-sgi-movie			;;
		mp2)		echo b video/mpeg				;;
		mp2a)		echo b audio/mpeg				;;
		mp3)		echo b audio/mpeg				;;
		mp4)		echo b video/mp4				;;
		mp4a)		echo b audio/mp4				;;
		mp4v)		echo b video/mp4				;;
		mpa)		echo b video/mpeg				;;
		mpc)		echo b application/x-project			;;
		mpe)		echo b video/mpeg				;;
		mpeg)		echo b video/mpeg				;;
		mpg)		echo b video/mpeg				;;
		mpg4)		echo b video/mp4				;;
		mpga)		echo b audio/mpeg				;;
		mpkg)		echo b application/vnd.apple.installer+xml	;;
		mpp)		echo b application/vnd.ms-project		;;
		ms)		echo a text/troff				;;
		msh)		echo b model/mesh				;;
		news)		echo a message/rfc822				;;
		nl)		echo a text/plain				;;
		nws)		echo a message/rfc822				;;
		odp)		echo b application/x-openoffice			;;
		ods)		echo b application/x-openoffice			;;
		odt)		echo b application/x-openoffice			;;
		oga)		echo b audio/ogg				;;
		ogg)		echo b application/ogg				;;
		ogm)		echo b application/ogg				;;
		ogv)		echo b video/ogg				;;
		ogx)		echo b application/ogg				;;
		p)		echo a application/x-chem			;;
		p10)		echo b application/pkcs10			;;
		p12)		echo b application/pkcs12			;;
		p7b)		echo b application/pkcs7-certificates		;;
		p7c)		echo b application/pkcs7-mime			;;
		p7m)		echo b application/pkcs7-mime			;;
		p7r)		echo b application/pkcs7-certreqresp		;;
		p7s)		echo b application/pkcs7-signature		;;
		pas)		echo a text/x-pascal				;;
		pbm)		echo b image/x-portable-bitmap			;;
		pct)		echo b image/pict				;;
		pcx)		echo b image/x-pcx				;;
		pdb)		echo a chemical/x-pdb				;;
		pdf)		echo b application/pdf				;;
		pem) 		echo a application/x-pem-file			;;
		pfx)		echo b application/pkcs12			;;
		pgm)		echo b image/x-portable-graymap			;;
		php)		echo a text/x-php				;;
		phtml)		echo a text/x-php				;;
		pic)		echo b image/pict				;;
		pict)		echo b image/pict				;;
		pkg)		echo b application/x-pkg			;;
		pl)		echo a text/x-perl				;;
		planner)	echo b application/x-planner			;;
		pm)		echo a text/x-perl-module			;;
		png)		echo b image/png				;;
		pnm)		echo b image/x-portable-anymap			;;
		pot)		echo b application/vnd.ms-powerpoint		;;
		pov)		echo a model/x-pov				;;
		ppm)		echo b image/x-portable-pixmap			;;
		pps)		echo b application/vnd.ms-powerpoint		;;
		ppt)		echo b application/vnd.ms-powerpoint		;;
		pptx)		echo b application/vnd.ms-powerpoint		;;
		ps)		echo b application/postscript			;;
		py)		echo a text/x-python				;;
		qt)		echo b video/quicktime				;;
		r[0-9][0-9])	echo b application/x-rar-compressed		;;
		ra)		echo b audio/x-realaudio			;;
		ram)		echo b audio/x-pn-realaudio			;;
		rar)		echo b application/x-rar-compressed		;;
		rm)		echo b audio/x-pn-realaudio			;;
		rmi)		echo b audio/midi				;;
		roff)		echo a text/troff				;;
		rpm)		echo b application/x-rpm			;;
		#rpm)		echo b audio/x-pn-realaudio			;; # duplicate
		rss)		echo b application/rss+xml			;;
		rtf)		echo b application/rtf				;;
		rtx)		echo a text/richtext				;;
		sass)		echo a text/x-sass				;;
		scm)		echo a application/x-scheme			;;
		scss)		echo a text/x-scss				;;
		sgm)		echo a text/sgml				;;
		sgml)		echo a text/sgml				;;
		sh)		echo a text/x-sh				;;
		shar)		echo a application/x-shar			;;
		shtml)		echo a text/html				;;
		silo)		echo b model/mesh				;;
		sit)		echo b application/x-stuffit			;;
		sl)		echo b application/octet-stream			;;
		smi)		echo b application/smil				;;
		smil)		echo b application/smil				;;
		smv)		echo b video/x-smv				;;
		snd)		echo b audio/basic				;;
		so)		echo b application/octet-stream			;;
		spc)		echo b application/pkcs7-certificates		;;
		spl)		echo b application/x-futuresplash		;;
		sql)		echo a text/x-sql				;;
		srp)		echo b application/x-rationalplan		;;
		ss)		echo a application/x-scheme			;;
		stm)		echo a text/html				;;
		sty)		echo a text/x-tex-style				;;
		svg)		echo b image/svg+xml				;;
		svgz)		echo b image/svg+xml				;;
		swf)		echo b application/x-shockwave-flash		;;
		t)		echo a text/troff				;;
		tar)		echo b application/x-tar			;;
		taz)		echo b application/x-tar-compress		;;
		tbz2)		echo b application/x-tar-bzip2			;;
		tcsh)		echo a text/x-tcsh				;;
		tex)		echo a application/x-tex			;;
		texi)		echo a application/x-texinfo			;;
		texinfo)	echo a application/x-texinfo			;;
		tga)		echo b image/x-targa				;;
		tgz)		echo b application/x-tar-gzip			;;
		tif)		echo b image/tiff				;;
		tiff)		echo b image/tiff				;;
		torrent)	echo b application/x-bittorrent			;;
		tpl)		echo a text/plain				;;
		tpu)		echo b application/x-tpu			;;
		tr)		echo a text/troff				;;
		ts)		echo b video/mp2t				;;
		#ts)		echo a application/x-typescript			;; # duplicate
		tsx)		echo a application/x-typescript			;;
		ttf)		echo a font/ttf					;;
		txt)		echo a text/plain				;;
		txz)		echo b application/x-tar-xz			;;
		tz)		echo b application/x-tar-compress		;;
		uml)		echo b application/x-uml			;;
		uu)		echo a text/x-uuencode				;;
		uue)		echo a text/x-uuencode				;;
		vba)		echo a text/x-vimball				;;
		vcf)		echo a text/x-vcard				;;
		vcs)		echo a text/x-vcalendar				;;
		vim)		echo a text/x-vim				;;
		viv)		echo b video/vnd.vivo				;;
		vivo)		echo b video/vnd.vivo				;;
		vob)		echo b video/x-ms-vob				;;
		voc)		echo b audio/x-voc				;;
		vrml)		echo b model/vrml				;;
		wav)		echo b audio/x-wav				;;
		wcm)		echo b application/vnd.ms-works			;;
		wdb)		echo b application/vnd.ms-works			;;
		webm)		echo b video/webm				;;
		webp)		echo b image/webp				;;
		wks)		echo b application/vnd.ms-works			;;
		wm)		echo b video/x-ms-wm				;;
		wmv)		echo b video/x-winmedia				;;
		wmx)		echo b video/x-ms-wmx				;;
		woff)		echo b font/woff				;;
		woff2)		echo b font/woff2				;;
		wp)		echo b application/wordperfect			;;
		wp5)		echo b application/wordperfect			;;
		wp6)		echo b application/wordperfect			;;
		wps)		echo b application/vnd.ms-works			;;
		wri)		echo b application/msword			;;
		wrl)		echo b model/vrml				;;
		wvx)		echo b video/x-ms-wvx				;;
		xbm)		echo b image/x-xbitmap				;;
		xcf)		echo b image/x-gimp				;;
		xhtml)		echo a application/xhtml+xml			;;
		xif)		echo b image/vnd.xiff				;;
		xla|xlc|xld)	echo b application/vnd.ms-excel			;;
		xlk|xll|xlm)	echo b application/vnd.ms-excel			;;
		xlsx)		echo b application/vnd.ms-excel			;;
		xls|xlt|xlv)	echo b application/vnd.ms-excel			;;
		xlw)		echo b application/vnd.ms-excel			;;
		xml)		echo a application/xml				;;
		xpm)		echo b image/x-xpixmap				;;
		xwd)		echo b image/x-xwindowdump			;;
		xyz)		echo a chemical/x-xyz				;;
		xz)		echo b application/x-xz				;;
		yenc)		echo b application/x-yenc-encoded		;;
		yml)		echo a application/x-yaml			;;
		ync)		echo b application/x-yencoded			;;
		yuv)		echo b video/x-oggyuv				;;
		z)		echo b application/x-compress			;;
		zip)		echo b application/zip				;;
		zoo)		echo b application/x-zoo			;;
		zsh)		echo a text/x-zsh				;;
		# individual files
		makefile)	echo a text/x-makefile				;;
		dockerfile)	echo a text/x-dockerfile			;;
		vagrantfile)	echo a text/x-vagrantfile			;;
		*)		echo b default					;;
	esac
}

############################################################################
# main

f_initialize "${argv0:=$(basename $0)}"

while getopts "8C:H:IM:R:Vab:c:df:himqr:s:uv" currentopt; do
	case $currentopt in
		C)	charset="$OPTARG"
			;;
		H)	if [ -n "$headerlines" ]; then
				headerlines=$(printf "%b\n" "$headerlines" "$OPTARG")
			else
				headerlines="$OPTARG"
			fi
			;;
		I)	inline_or_attachment=inline
			specify_inline_filename=1
			;;
		M)	mimetype="$OPTARG"
			;;
		V)	verbose=1
			;;
		a)	inline_or_attachment=inline
			specify_inline_filename=
			mixed_or_alternative=alternative
			;;
		d)	MAILATT_DEBUG=1
			;;
		[muq8])	f_select_encoder $currentopt
			;;
		[bcfrR]) f_add_addresses "$OPTARG"
			;;
		h)	f_usage
			exit 0
			;;
		i)	inline_or_attachment=inline
			specify_inline_filename=
			;;
		s)	subject="Subject: $(f_encode_header "$OPTARG")"
			;;
		v)	f_version
			exit 0
			;;
		*)	# 'getopts' already gives a message on stderr
			f_usage 1>&2
			exit 1
			;;
	esac
done

if eval "test \"x\$$((OPTIND-1))\"" = 'x--'; then
	end_opts=1
fi

shift $((OPTIND-1))

f_composemail "$@" | f_sendmail

exit $?

############################################################################
# documentation

=pod

=for section 1

=head1 NAME

B<mailatt> - send e-mail with attachments

=head1 SYNOPSIS

=for roff
.ad l

S<< C<mailatt [>I< message options >C<|>I< encoding options >C<|>I< header options> >>
S<< C<|>I< debug options >C<]> >>
S<< C<[>I< encoding options >C<| -- |>I< file1 >C<[>I< file2>... C<] ]> >>

C<mailatt { -h | -v }>

=over 4

=item Message options:

S<<  C<[ -Iai ]>                          >>

=item Header options:

S<<  C<[ -r >I<recipients>C< ]>           >>
S<<  C<[ -c >I<cc-addresses>C< ]>         >>
S<<  C<[ -b >I<bcc-addresses>C< ]>        >>
S<<  C<[ -f >I<from>C< ]>                 >>
S<<  C<[ -R >I<reply-to-addresses>C< ]>   >>
S<<  C<[ -s >I<subject>C< ]>              >>
S<<  C<[ -H >I<headerline>C< ]>           >>

=item Encoding options:

S<<  C<[ -C >I<charset>C< ]>              >>
S<<  C<[ -M >I<mime-type>C< ]>            >>
S<<  C<[ -8mqu ]>                         >>

=item Debug options:

S<<  C<[ -Vd ]>                           >>

=back

=for roff
.ad n

Please note that the order of the commandline options is significant.

=head1 DESCRIPTION

B<mailatt> is used to send multipart MIME e-mail with file attachments
of any format.

=over 3

=item -

Files of type I<text/*> and those that are known to be ASCII-only (like many
script types) will be attached using quoted-printable encoding by default
(but see the B<-m> option below).

These files are supposed to be clean 7-bit ASCII unless another character
set has been specified on the commandline.  See the B<-C> option below.

=item -

Binary files (I<i.e.> files having MIME types other than I<text/*>) will
be attached using base64 encoding by default (but see the B<-q> option below).

=item -

Files of type I<message/*> or I<multipart/*> will always be attached using
8bit-encoding, because of requirements imposed by RFC 2045.

=back

B<mailatt> can send messages in two possible formats:

=over 4

=item I<multipart/mixed>

This is the default.  It signifies that the message contains a collection
of files which are not necessarily related.

=item I<multipart/alternative>

This message type can be used to provide alternative representations of the
same file (I<e.g.> plain text and HTML), in which case the mail client
can select one to present.  See also the B<-a> option below.

=back

=head1 OPTIONS

=over 4

=item -8

This option may be used multiple times, and in any position on the commandline.
It indicates that B<8bit> should be used as Content-Transfer-Encoding
for all subsequent attachments (header lines will be base64-encoded).

B<Warning>: not all e-mail clients support this.  The use of this option
is therefore discouraged; use B<-m> instead.

See also B<-m> and B<-q>.

=item -C I<charset>

This option may be used multiple times, and in any position on the
commandline.  It specifies the character set to be used for all subsequent
attachments and header lines.  If unspecified, US-ASCII is used.
See the EXAMPLES below.

Some often used character sets:

    US-ASCII     ISO-8859-6    GB18030        Windows-1251
    UTF-8        ISO-8859-7    GB2312         Windows-1252
    UTF-16       ISO-8859-8    Shift_JIS      Windows-1253
    ISO-8859-1   ISO-8859-9    KOI8-R         Windows-1254
    ISO-8859-2   ISO-8859-15   KOI8-U         Windows-1255
    ISO-8859-3   EUC-JP        Big5           Windows-1256
    ISO-8859-4   EUC-KR        Windows-874    Windows-1257
    ISO-8859-5   EUC-CN        Windows-1250   Windows-1258

=item -H I<headerline>

Specifies a line to add to the mail header. This option can be used
multiple times. Do not end the line with a newline character.

=item -I

This option is nearly identical to B<-i>, but uses the "old" behavior,
which is to include a filename for all MIME parts, even those that are
attached using C<Content-Disposition: inline>.

B<Warning>: not all e-mail clients support this.  This option is
provided only for backward-compatibility.  The use of this option
is therefore discouraged; use B<-i> instead.

=item -M I<mime-type>

Specifies the MIME type to be used for the next file on the commandline.
If not specified, the MIME type is inferred from the filename extension.

=item -R I<addr1>[,I<addr2...>]

Specify Reply-To: addresses for the e-mail. See B<-r> for allowed formats.

=item -V

For debugging purposes only.  The name of each file will be reported on
I<stderr> when it is attached.

=item -a

Use I<multipart/alternative> for the mail message instead of the default
I<multipart/mixed>.  All message parts will automatically be included
with C<Content-Disposition: inline>, regardless of any B<-i> option.
Note that the simplest representation of the mail (probably I<text/plain>)
should be attached first.

=item -b I<addr1>[,I<addr2...>]

Specify Bcc: addresses for the e-mail. See B<-r> for allowed formats.

=item -c I<addr1>[,I<addr2...>]

Specify Cc: addresses for the e-mail. See B<-r> for allowed formats.

=item -d

For debugging purposes only. The composed mail will be printed on I<stdout>
instead of actually being sent. This option takes precedence over the
MAILATT_DEBUG variable (see below).

=item -f I<addr1>

Specify From: address for the e-mail.

=item -h

Print help (usage information) and exit.

=item -i

Specifies that the first file on the commandline must be forcibly included
with a C<Content-Disposition: inline> header, and without a filename.
If this option is not specified, all parts of the message will be included
with C<Content-Disposition: attachment> and a specified filename.

The option B<-a> takes precedence over B<-i>.

=item -m

This option may be used multiple times, and in any position on the commandline.
It indicates that B<base64> should be used as Content-Transfer-Encoding
for all subsequent attachments and header lines.  This is the default
if unspecified.

This option is called B<-m> as a reference to mmencode(1). However,
B<mailatt> does not require any external mmencode(1) program; instead,
it handles the encoding itself.

See also B<-q>.

=item -q

This option may be used multiple times, and in any position on the commandline.
It indicates that B<quoted-printable> should be used as Content-Transfer-Encoding
for all subsequent attachments and header lines.

Although quoted-printable is normally only used for ASCII attachments,
B<mailatt> also supports this encoding for binaries.

See also B<-m>.

=item -r I<addr1>[,I<addr2...>]

Specify recipients (To: addresses) for the e-mail.

Each one of the addresses may be specified in one of the following
formats:

=over 4

=over

=item I<user>

=item <I<user>>

=item <I<user>@I<domain>>

=item I<name> <I<user>>

=item I<name> <I<user>@I<domain>>

=back

=back

The first two forms will be expanded (using the system F<passwd> file or (if
configured) the NIS F<passwd> map) to the form "I<name>S< ><I<user>>", which
the mailer system may further expand to "I<name>S< ><I<user>@I<domain>>".

The B<-r> option is strictly speaking not mandatory for B<mailatt>, but it
is for programs like sendmail(1).

=item -s I<subject>

Specify subject for the e-mail.

=item -u

This option may be used multiple times, and in any position on the commandline.
It indicates that B<uuencode> should be used as Content-Transfer-Encoding
for all subsequent attachments (header lines will be base64-encoded).

B<mailatt> does not require any external uuencode(1) program; instead, it
handles the encoding itself.

B<Warning>: not all e-mail clients support this.  The use of this option
is therefore discouraged; use B<-m> instead.

See also B<-m> and B<-q>.

=item -v

Display version information and exit.

=item --

Indicates that no more options follow; all the remaining commandline
arguments are to be interpreted as filenames.

=item I<file1> [ I<file2>... ]

Indicate which files should be attached to the mail.  Depending on the
"extension" (I<i.e.> the filename part following a C<.> in the filename),
a corresponding MIME type will be selected from a built-in list.

If the file type is not known or the extension is empty, the file will be
sent as type I<application/octet-stream>, unless the B<-a> or B<-i>
option requires it to be included inline.  In that case, the MIME type
will be reported as I<text/plain>.

At most one of the filenames may be specified as a single C<-> (minus),
which will cause B<mailatt> to read a document from stdin. If entered
from the terminal, such a document should be ended with the I<eof>-character
(usually CTRL-D). B<mailatt> will assume that this document is of
type I<text/plain>, unless indicated otherwise with B<-M>.

=back

=head1 EXAMPLES

Send all F<*.eps> files to two recipients:

  mailatt -s'Filesystem usage' -r alexander,maxima fsgraph-*.eps

Send a file fragment, carbon copy to the sysadmin (possibly forwarded by
a F<.forward> file):

  mailatt -s'Fragment 2/10' -r beatrix -c root dumps.tar.gz.xab

Send a formatted file, preceded by an introductory message, typed
interactively:

  mailatt -s'Sendmail manual' -r sysadmin@domain.nl -i - sendmail.pdf
  Hello Bernhard,
  Here is the sendmail manual I promised.
  ^D

Send a formatted mail in HTML format, specifying a From: address:

  mailatt -f 'Pieter <pvvollenhoven@hotmail.com>' -r margriet
          -i birthdaycard.html

Send a mail in both plain text and HTML format:

  mailatt -a -r constantijn,friso -s greeting.txt greeting.html

Attach a file of unknown MIME type using quoted-printable encoding (I<e.g.>
to increase readability).  This overrules the default encoding (base64)
that is used for attachments of unknown MIME type coming I<before> the
B<-q> option.

  mailatt -r christina -s "config files" -i body.txt
          /etc/sendmail.cf -q /etc/hosts

Send a mail using the Cyrillic character set to multiple addresses:

  mailatt -r 'Mr. Putin <putin@kremlin.ru>,root'
          -s 'Important letter' -i -C ISO-8859-5 letter.txt

Add custom lines to the mail header:

  mailatt -r 'Benedictus_XVI@vatican.va' -s 'Oldest translation'
          -i -H "X-Year-Finished: 1637" message.txt SV.pdf

Add a Sender: line to the mail header:

  mailatt -r all@company.com -s 'Important announcement' -i
          -H 'Sender: secretary@company.com' -f ceo@company.com
          message.html

Send a mail with mixed character sets:

=for roff
.PP
.Vb 2
.ie \n(.g \{\
\&  mailatt -C ISO-8859-15 -r 'Fran\(,cois <francois@nimporte.ou>'
\&          -s 'All\(^o' -C UTF-8 -i message.html -C windows-1253 m.txt
.\}
.el \{\
\&  mailatt -C ISO-8859-15 -r 'Franc\*,ois <francois@nimporte.ou>'
\&          -s 'Allo\*^' -C UTF-8 -i message.html -C windows-1253 m.txt
.\}
.Ve
.PP

Send a mail with specified MIME types:

  mailatt -r amalia -i greeting.txt
          -M application/x-rpm mailcap-2.1.31.noarch.rpm
          -M audio/x-pn-realaudio recording.rpm

Specify the MIME type of an attachment fed via stdin:

  mailatt -r alexia -s 'Holiday pictures' -i -C ISO-Latin-15
          -M text/html - skiing-1.jpg skiing-2.jpg < greeting.html

=head1 ENVIRONMENT

=over 4

=item MAILATT_DEBUG

For debugging purposes only. If set and not B<0>, causes the composed mail
to be printed on I<stdout> instead of actually being sent.

=back

=head1 BUGS and WARNINGS

This script aims to run out of the box in ksh(1) and bash(1) on a wide variety
of Un*x-like platforms (such as AIX, HP-UX, SunOS, Solaris, Darwin, FreeBSD
and Linux (SuSE, Debian, CentOS)), but has not yet been tested on all of them.

RFC 5322 warns that lines of characters in the body MUST be limited to 998
characters. If a file of type I<message/*> or I<multipart/*> is attached,
this is not enforced, since the file is attached as-is.

=head1 SEE ALSO

base64(1), mail(1), mailx(1), mmencode(1), sendmail(8), uuencode(1).

=over 10

=item RFC 822:

Format of Internet Text Messages

=item RFC 1049:

The Content-Type Header Field for Internet Messages

=item RFC 2045:

MIME: Format of Internet Message Bodies

=item RFC 2046:

MIME: Media Types

=item RFC 2047:

MIME: Message Header Extensions for Non-ASCII Text

=item RFC 2183:

The Content-Disposition Header Field

=item RFC 2387:

The multipart/related Content-Type

=item RFC 2392:

Content-ID and Message-ID URLs

=item RFC 2822:

Internet Message Format

=item RFC 4648:

The Base16, Base32, and Base64 Data Encodings

=item RFC 5322:

Internet Message Format

=begin comment

RFC 1521: MIME Part One: Mechanisms for Specifying and Describing the Format of Internet Message Bodies
RFC 1522: MIME Part Two: Message Header Extensions for Non-ASCII Text
RFC 2646: The text/plain Format parameter
RFC 4021: Registration of Mail and MIME Header Fields

Character sets:
https://www.iana.org/assignments/character-sets/character-sets.xhtml
http://nixnik.50webs.com/lynx/lynx_cfg.d/character_sets.html
https://www.ibm.com/support/knowledgecenter/en/SSVRGU_10.0.1/basic/LSAZ_APPENDIX_E_MIME_CHARSET_NAMES.html

=end comment

=back

=head1 VERSION

=for roff
.PP \" display the 'pertains to'-macro
.Vp \*(Vw

=head1 AUTHOR and COPYRIGHT

=for roff
.\" the \(co macro only exists in groff
.ie \n(.g Copyright \(co \*(Yr, Ren\('e
.el       Copyright (c) \*(Yr, Rene\*'
Uittenbogaard (ruittenb@users.sourceforge.net)

This program is free software; you can redistribute it and/or modify it
under the terms described by the GNU General Public License version 3.

C<mailatt> is distributed without any warranty, even without the
implied warranties of merchantability or fitness for a particular purpose.

=cut

