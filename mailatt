#!/usr/local/bin/bash
#!/bin/ksh
#
############################################################################
#
# Name:		mailatt
# Version:	1.17
# Created:	2011-02-11
# Date:		2019-03-25
# Author:	Rene Uittenbogaard
# Requires:	sendmail
# Usage:	mailatt [ -r <recipient> ] [ -c <cc-addr> ] [ -b <bcc-addr> ]
#			[ -f <from> ] [ -R <reply-to> ] [ -s <subject> ]
#			[ -H <headerline> ] [ -d ] [ -Iai ] [ -8mqu ]
#			[ -C <charset> ] [ -M mimetype ] [ <file1> .. <filen> ]
#		mailatt { -h | -v }
#
# TODO:		test: unfolded header lines
#		bug?: line endings in the body should be CRLF; handled by f_onlcr;
#		      but we can only do that if we encode unix-style line endings.
#		feat: implement multipart/related using content-id?
#		feat: Content-MD5 header?
#		feat: internal uuencoder
#

# The main program code starts at the label '# main'

############################################################################
# version info for *roff

version='

=pod

=for roff
.ds Yr 2011-2019
.ds Vw @(#) mailatt 1.17
.de Vp
This manual pertains to \fBmailatt\fP version \\$3.
..
.hy 0 \" hyphenation off \

=cut '

############################################################################
# functions

f_initialize() {
	f_setpath
	f_findawk
	f_select_encoder init
	f_find_cid_data
	source mime-identify ''
	attno=0
	charset=us-ascii
	mixed_or_alternative=mixed
	inline_or_attachment=attachment
}

f_setpath() {
	# SunOS 5.7 has sendmail installed in /usr/lib
	# SunOS 5.8 has a broken /usr/ucb/echo, don't put it in front!
	PATH=/usr/sbin:$PATH:/usr/ucb:/usr/ccs/bin:/usr/xpg4/bin:/usr/local/bin:/usr/lib
}

f_findawk() {
	if f_has gawk; then
		awk=gawk
	elif [ -x /usr/xpg4/bin/awk ]; then
		awk=/usr/xpg4/bin/awk
	elif f_has mawk; then
		awk=mawk
	elif f_has nawk; then
		awk=nawk
	else
		awk=awk
	fi
}

f_echo() {
	printf "%b\n" "$*"
}

f_echon() {
	printf "%b" "$*"
}

f_usage() {
	f_echo "Usage: $argv0 [ -r <recipient> ] [ -c <cc-addr> ] [ -b <bcc-addr> ]"
	f_echo "\t\t[ -f <from> ] [ -R <reply-to> ] [ -s <subject> ]"
	f_echo "\t\t[ -H <headerline> ] [ -8Iadimqu ]"
	f_echo "\t\t[ -C <charset> ] [ -M <mime-type> ] [ <file1> .. <filen> ]"
	f_echo "       $argv0 { -h | -v }"
}

f_version() {
	f_echo "$version" | $awk '/@[(]#[)]/ { sub(".*@[(]#[)] ?", ""); print }'
}

f_getusername() {
	# find name from password file (GCOS field) or NIS
	{
		# Is NIS active? Then give it preference over local passwd
		if f_has domainname && test "`domainname 2>/dev/null`"; then
			ypmatch "$1" passwd 2>/dev/null
		fi
		# Always consult local passwd
		cat /etc/passwd
	} | $awk -F: '$1 == "'"$1"'" { sub(/,.*/, "", $5); print $5 }'
}

f_notify_interactive() {
	test -t 0 && f_echo "Reading document from stdin..." 1>&2
}

f_lowercase() {
	# tr '[:upper:]' '[:lower:]' # needs LC_CTYPE to function correctly
	f_echo "$@" | tr A-Z a-z
}

f_has() {
	# The built-in "which" does not always set $? correctly and cannot always be silenced.
	# This function is completely silent.
	# This tr(1) invocation is safe because directories in PATH cannot contain colons.
	for i in $(echo $PATH | tr : " "); do
		test -x "$i/$1" 2>/dev/null && return 0
	done
	return 1
}

f_find_cid_data() {
	cidtime="$(date +"%Y%m%d%H%M%S")"
	cidrandom="`f_boundbits`"
	cidhost="$(hostname)" 2>/dev/null
}

f_fold() {
	fname="$#"
	# RFC 5322: Lines of characters in the body MUST be limited to 998 characters.
	if [ "x$1" == x- ]; then
		# Darwin doesn't support '-' as inputfile for stdin
		fold -w992
	else
		fold -w992 "$1"
	fi
}

f_onlcr() {
	$awk '{
		sub(/\015$/, "")
		printf("%s\r\n", $0)
	}'
}

f_encode_header() {
	if [ "$(f_lowercase $charset)" = us-ascii ]; then
		f_echo "$1"
	else
		indent=
		f_echon "$1" | f_dissect | f_extend_linelen 330 | $awk 'NF > 1 { print }' | while read header_line;
		do
			encoded="$(f_echon "$header_line" | $header_encoder 1)"
			f_echo "${indent}=?${charset}?${header_encoding}?${encoded}?="
			indent='\t'
		done
	fi
}

f_add_address() {
	# allowed values for $addr:
	#	user
	#	<user>
	#	<user@domain>
	#	name <user>
	#	name <user@domain>
	# test whether $addr is of the form user <user@dom>
	if [ "${addr##*<}" != "$addr" ]; then
		# split into 'name' and 'user[@domain]' parts
		fullname="${addr%<*}"
		while [ "${fullname% }" != "$fullname" ]; do
			fullname="${fullname% }"
		done
		addr="${addr##*<}"
		addr="${addr%>}"
	else
		fullname=
	fi
	if [ "${addr#*@}" = "$addr" -a -z "$fullname" ]; then
		fullname="$(f_getusername "$addr")"
	fi
	addressline="${addressline:+$addressline, }${fullname:+$(f_encode_header "$fullname") }<$addr>"
}

f_add_addresses() {
	optarg="$1"
	addressline=
	if   [ "$currentopt" = r ]; then
		to="To:"
	elif [ "$currentopt" = c ]; then
		to="Cc:"
	elif [ "$currentopt" = b ]; then
		to="Bcc:"
	elif [ "$currentopt" = R ]; then
		to="Reply-To:"
	else
		to="From:"
		optarg="${optarg%%,*}"
	fi
	while [ "${optarg#*,}" != "$optarg" ]; do
		addr="${optarg%%,*}"
		optarg="${optarg#*,}"
		f_add_address
	done
	addr="$optarg"
	f_add_address
	if [ "$currentopt" = f ]; then
		envelope_from="-f $addr"
	fi
	addresses="$to $addressline${addresses:+\\n$addresses}"
}

# not all systems have mmencode(1); therefore, we'll encode it here
f_base64encode_bytes() {
	# Tested on:
	#	HP-UX 10.20
	#	HP-UX 11.11
	#	AIX 4.2
	#	SunOS 5.8
	#	SuSE UnitedLinux 1.0
	#	Debian 3.0
	#	Darwin 17.7.0
	$awk -v inheader="$1" '
		# encode file to base64
		# remotely based on a script by Peter van Eerten (c) March 6 2003
		# note: for this implementation, the input line MUST have an exact multiple of 3 no. of bytes
		#
		function store(n) {
			buffer[bufindex++] = n
			if (bufindex > 3) {
				spout(buffer[1], buffer[2], buffer[3])
				bufindex = 1
			}
		}
		function flush() {
			if (bufindex >= 2) {
				if (bufindex == 2) buffer[2] = 0
				spout(buffer[1], buffer[2], 0)
			}
			if (!inheader) printf("\n")
		}
		function spout(byte1, byte2, byte3) {
			result = ""
			# Create BASE64 values
			base1 = int(byte1 / 4)
			base2 = ((byte1 %  4) * 16) + int(byte2 / 16)
			base3 = ((byte2 % 16) *  4) + int(byte3 / 64)
			base4 = (byte3 % 64)
			# Compose BASE64 string
			if (bufindex == 2){
				result = result substr(BASE64, base1 + 1, 1)
				result = result substr(BASE64, base2 + 1, 1)
				result = result "=="
			}
			if (bufindex == 3){
				result = result substr(BASE64, base1 + 1, 1)
				result = result substr(BASE64, base2 + 1, 1)
				result = result substr(BASE64, base3 + 1, 1)
				result = result "="
			}
			if (bufindex > 3){
				result = result substr(BASE64, base1 + 1, 1)
				result = result substr(BASE64, base2 + 1, 1)
				result = result substr(BASE64, base3 + 1, 1)
				result = result substr(BASE64, base4 + 1, 1)
			}
			printf(result)
		}
		BEGIN {
			bufindex   = 1
			BASE64     = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
		}
		NF > 1 {
			for (i = 2; i <= NF; i++) store($i)
#			if (!inheader) printf("\n")
			flush()
		}
#		END {
#			flush()
#		}
	'
}

f_qpencode_bytes() {
	# Tested on:
	#	HP-UX 10.20
	#	HP-UX 11.11
	#	AIX 4.2
	#	SunOS 5.8
	#	SuSE UnitedLinux 1.0
	#	Debian 3.0
	#	Darwin 17.7.0
	$awk -v inheader="$1" -v linewise="$2" '
		NF > 1 {
			if (NR > 1) printf("%s", (inheader ? "\n  " : "=\n"))
			for (i = 2; i <= NF; i++) {
				# 61 is the equals sign
				# 46 is the full stop, causes errors at start of line
				#
				if (($i > 32) && ($i != 46) \
					&& ($i != 61) && ($i < 127))	printf("%c", $i)
				else if (($i == 32) && (!inheader) \
					&& (i > 2) && (i < NF))		printf(" ")
				else if (($i == 10) && (!inheader) \
					&& linewise)			printf("=0A=\n")
				else					printf("=%02X", $i)
			}
		}
		END {
			if (!inheader) printf("\n")
		}
	'
}

f_base64encode_file() {
	f_dissect ${1:+"$1"} | f_extend_linelen 53 | f_base64encode_bytes 0
}

f_qpencode_file() {
	f_dissect ${1:+"$1"} | f_extend_linelen 23 | f_qpencode_bytes 0
}

f_qpencode_file_linewise() {
	f_dissect ${1:+"$1"} | f_extend_linelen 72 | f_qpencode_bytes 0 1
}

f_extend_linelen() {
	$awk -v maxfields="${1:-17}" '
		BEGIN {
			# the first field is not accurate any more,
			# but it is discarded by f_*encode_line anyway
			printf("0000000")
		}
		{
			for (i = 2; i <= NF; i++) {
				printf(" %3d", $i)
				if (++r > maxfields) {
					r = 0
					printf("\n%s", "0000000")
				}
			}
		}
		END {
			printf("\n")
		}
	'
}

f_dissect() {
	# some platforms don't have od(1)
	if [ `uname` = FreeBSD -o `uname` = Darwin ]; then
		if [ "x$1" == x- ]; then
			# Read from stdin. Not all versions of hexdump(1)
			# support '-' as a shorthand for stdin.
			arg=
		else
			arg="$1"
		fi
		hexdump -v -e '"%06.6_ao " 16/1 "%3u " "\n"' ${arg:+"$arg"}
	else
		od -t u1 -v ${1:+"$1"}
	fi
}

f_select_encoder() {
	case "$1" in
		u)	if f_has uuencode; then
				bin_encoding=uuencode
				bin_encoder=uuencode
				asc_encoding=uuencode
				asc_encoder=uuencode
				header_encoding=B
				header_encoder=f_base64encode_bytes
			else
				f_echo "$argv0: Warning: no uuencode found, using base64 instead" 1>&2
				f_select_encoder m
			fi
			;;
		m)	bin_encoding=base64
			bin_encoder=f_base64encode_file
			asc_encoding=base64
			asc_encoder=f_base64encode_file
			header_encoding=B
			header_encoder=f_base64encode_bytes
			;;
		q)	bin_encoding=quoted-printable
			bin_encoder=f_qpencode_file
			asc_encoding=quoted-printable
			asc_encoder=f_qpencode_file_linewise
			header_encoding=Q
			header_encoder=f_qpencode_bytes
			;;
		8)	bin_encoding=8bit
			bin_encoder=cat
			asc_encoding=8bit
			asc_encoder=cat
			header_encoding=B
			header_encoder=f_base64encode_bytes
			;;
		init)	bin_encoding=base64
			bin_encoder=f_base64encode_file
			asc_encoding=quoted-printable
			asc_encoder=f_qpencode_file_linewise
			header_encoding=B
			header_encoder=f_base64encode_bytes
			;;
		*)	bin_encoding=binary
			bin_encoder=cat
			asc_encoding=binary
			asc_encoder=cat
			header_encoding=B
			header_encoder=f_base64encode_bytes
			;;
	esac
}

f_boundbits() {
	echo "$RANDOM $RANDOM * $RANDOM * $$ * 63o p" | dc | $awk 'BEGIN {
		set="0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz_";
	}
	{
		for (i=1;i<=NF;i++) {
			printf(substr(set, $i+1, 1));
		}
	}
	END {
		print "";
	}'
}

f_startmail() {
	test "$addresses"   && f_echo "$addresses"
	test "$subject"     && f_echo "$subject"
	test "$headerlines" && f_echo "$headerlines"
	boundary="Mailatt=Part:$RANDOM.$(f_boundbits)+$(f_boundbits)/"
	cat <<-_MIME_header_preamble_
		MIME-Version: 1.0
		Content-Type: multipart/$mixed_or_alternative; boundary="$boundary"
		X-Mailer: $(f_version)
		
		This is a multipart message in MIME format.
		If your mail reader displays this preamble, it does not support MIME.
		
	_MIME_header_preamble_
}

f_endmail() {
	f_echo "--$boundary--"
}

f_sendmail() {
	f_onlcr | if [ "${MAILATT_DEBUG#0}" ]; then
		cat
	else
		sendmail -t -i $envelope_from
	fi
}

f_contentid() {
	f_echo "$cidtime.$cidrandom.$attno.${fname}@$cidhost" | sed 's/>/_/g'
}

f_composemail() {
	f_startmail
	f_process_all_files "$@"
	f_endmail
}

f_binattach() {
	f_echo "Content-Transfer-Encoding: $bin_encoding"
	f_echo
	if [ "$bin_encoding" = uuencode ]; then
		$bin_encoder "$1" "$2"
	else
		$bin_encoder "$1"
	fi
}

f_ascattach() {
	f_echo "Content-Transfer-Encoding: $asc_encoding"
	f_echo
	if [ "$asc_encoding" = uuencode ]; then
		$asc_encoder "$1" "$2"
	else
		$asc_encoder "$1"
	fi
}

f_msgattach() {
	# RFC 2045 states: it is EXPRESSLY FORBIDDEN to use any encodings
	# other than "7bit", "8bit", or "binary" with any composite media type,
	# i.e. one that recursively includes other Content-Type fields.
	# Currently the only composite media types are "multipart" and "message". 
	#
	f_echo "Content-Transfer-Encoding: 8bit"
	f_echo
	cat "$1"
}

f_attachit() {
	let attno=attno+1
	if [ "$specify_inline_filename" -o "$inline_or_attachment" = attachment ]; then
		namespec="; name=\"$neatname\""
		fnamespec="; name=\"$neatname\""
	else
		namespec=
		fnamespec=
	fi
	f_echo "--$boundary"
	f_echo "Content-ID: <$(f_contentid "$fname")>"
	f_echo "Content-Disposition: $inline_or_attachment$fnamespec"
	if [ "${contenttype%%/*}" == message   \
	-o   "${contenttype%%/*}" == multipart ];
	then
		f_echo "Content-Type: $contenttype; charset=\"$charset\"$namespec"
		f_msgattach "$fname" "$neatname"
	elif [ "$ascbin" == a ]; then
		f_echo "Content-Type: $contenttype; charset=\"$charset\"$namespec"
		f_ascattach "$fname" "$neatname"
	else # [ $ascbin == b ]
		f_echo "Content-Type: $contenttype$namespec"
		f_binattach "$fname" "$neatname"
	fi
}

f_attachment() { # {a|b} mimetype
	ascbin="$1"
	contenttype="$2"
	if [ "$contenttype" = default ]; then
		if [ "$inline_or_attachment" = inline ]; then
			contenttype=text/plain
			ascbin=a
		else
			contenttype=application/octet-stream
		fi
	fi
	if [ "x$fname" = x- ]; then
		f_notify_interactive
		neatname=stdin
	elif [ ! -r "$fname" ]; then
		f_echo "$argv0: Cannot attach \"$fname\": file not readable" >&2
		f_echon "Send mail anyway? (y/n) [n] " >&2
		read ans < /dev/tty
		if [ "${ans#n}" != "$ans" -o -z "$ans" ]; then
			exit 2
		else
			return
		fi
	else
		neatname="$(basename "$fname")"
	fi
	f_attachit
}

f_process_all_files() {
	for opt in "$@"; do
		# process options, if any might follow
		if [ -z "${end_opts#0}" ]; then
			if [ "$charset_coming_up" ]; then
				charset="$opt"
				charset_coming_up=
				continue
			elif [ "x${opt#-C}" != "x$opt" ]; then
				charset="${opt#-C}"
				if [ -z "$charset" ]; then
					charset_coming_up=1
				fi
				continue
			elif [ "$mimetype_coming_up" ]; then
				mimetype="$opt"
				mimetype_coming_up=
				continue
			elif [ "x${opt#-M}" != "x$opt" ]; then
				mimetype="${opt#-M}"
				if [ -z "$mimetype" ]; then
					mimetype_coming_up=1
				fi
				continue
			elif [ "x${opt#-[muq8]}" != "x$opt" ]; then
				f_select_encoder ${opt#-}
				continue
			elif [ "x$opt" = x-- ]; then
				end_opts=1
				continue
			fi
		fi

		# process file
		f_process_one_file "$opt" $mimetype
		mimetype=

		# switch content-disposition for all following files
		# from inline to attachment if multipart/mixed,
		# but not for multipart/alternative
		if [ "$mixed_or_alternative" != alternative ]; then
			inline_or_attachment=attachment
		fi
	done
}

f_process_one_file() {
	fname="$1"
	mimetype="$2" # explicit mimetype requested?
	if [ "${mimetype%%/*}" == text ]; then
		f_attachment a "$mimetype"
		return
	elif [ "$mimetype" ]; then
		f_attachment b "$mimetype"
		return
	fi
	if [ "x$fname" = x- ]; then
		f_attachment a text/plain
	else
		f_attachment $(f_mime_identify "$fname")
	fi
}

############################################################################
# main

f_initialize "${argv0:=$(basename $0)}"

while getopts "8C:H:IM:R:ab:c:df:himqr:s:uv" currentopt; do
	case $currentopt in
		C)	charset="$OPTARG"
			;;
		H)	if [ "$headerlines" ]; then
				headerlines=$(printf "%b\n" "$headerlines" "$OPTARG")
			else
				headerlines="$OPTARG"
			fi
			;;
		I)	inline_or_attachment=inline
			specify_inline_filename=1
			;;
		M)	mimetype="$OPTARG"
			;;
		a)	inline_or_attachment=inline
			specify_inline_filename=
			mixed_or_alternative=alternative
			;;
		d)	MAILATT_DEBUG=1
			;;
		[muq8])	f_select_encoder $currentopt
			;;
		[bcfrR]) f_add_addresses "$OPTARG"
			;;
		h)	f_usage
			exit 0
			;;
		i)	inline_or_attachment=inline
			specify_inline_filename=
			;;
		s)	subject="Subject: $(f_encode_header "$OPTARG")"
			;;
		v)	f_version
			exit 0
			;;
		*)	f_echo "$argv0: Invalid option: $currentopt" 1>&2
			f_usage
			exit 1
			;;
	esac
done

if eval "test \"x\$$((OPTIND-1))\"" = 'x--'; then
	end_opts=1
fi

shift $((OPTIND-1))

f_composemail "$@" | f_sendmail

exit $?

############################################################################
# documentation

=pod

=for section 1

=head1 NAME

B<mailatt> - send e-mail with attachments

=head1 SYNOPSIS

C<mailatt>
S<<	C<[ -r >I<recipients>C< ]>		>>
S<<	C<[ -c >I<cc-addresses>C< ]>		>>
S<<	C<[ -b >I<bcc-addresses>C< ]>		>>
S<<	C<[ -f >I<from>C< ]>			>>
S<<	C<[ -R >I<reply-to-addresses>C< ]>	>>
S<<	C<[ -s >I<subject>C< ]>			>>
S<<	C<[ -H >I<headerline>C< ]>		>>
S<<	C<[ -8Iadimqu ]>			>>
S<<	C<[ -C >I<charset>C< ]>			>>
S<<	C<[ -M >I<mime-type>C< ]>		>>
S<<	C<[ >I<file1 .. filen>C< ]>		>>

C<mailatt { -h | -v }>

Please note that the order of the commandline options is significant.
See especially B<-8CMmqu>.

=head1 DESCRIPTION

B<mailatt> is used to send multipart MIME e-mail with file attachments
of any format.

=over 3

=item -

Plaintext files are supposed to be clean 7-bit ASCII unless another character
set has been specified on the commandline.  See the B<-C> option below.

=item -

Files of type I<text/*> and those that are known to be ASCII-only will be
attached using quoted-printable encoding by default (but see the B<-m> and B<-q>
options below).

=item -

Files of type I<message/*> or I<multipart/*> will always be attached using
8bit-encoding, as required by RFC 2045.

=item -

Binary files (I<i.e.> files having MIME types other than I<text/*>) will
be attached using base64 encoding by default (but see the B<-m> and B<-q>
options below).

=back

B<mailatt> can send messages in two possible formats.  I<multipart/mixed>
is used to send a collection of files which are not necessarily related.
I<multipart/alternative> is used to provide alternative representations
of the same message (I<e.g.> plain text and HTML), in which case the mail
client can select one to present.  See also the B<-a> option below.

=head1 OPTIONS

=over 4

=item -8

This option may be used multiple times, and in any position on the commandline.
It indicates that B<8bit> should be used as Content-Transfer-Encoding
for all subsequent attachments (header lines will be base64-encoded).

B<Warning>: not all e-mail clients support this.  The use of this option
is therefore discouraged; use B<-m> instead.

See also B<-m> and B<-q>.

=item -C I<charset>

This option may be used multiple times, and in any position on the
commandline.  It specifies the character set to be used for all subsequent
attachments and header lines.  If unspecified, US-ASCII is used.
See the EXAMPLES below.

Some often used character sets:

    US-ASCII     ISO-8859-6    GB18030        Windows-1251
    UTF-8        ISO-8859-7    GB2312         Windows-1252
    UTF-16       ISO-8859-8    Shift_JIS      Windows-1253
    ISO-8859-1   ISO-8859-9    KOI8-R         Windows-1254
    ISO-8859-2   ISO-8859-15   KOI8-U         Windows-1255
    ISO-8859-3   EUC-JP        Big5           Windows-1256
    ISO-8859-4   EUC-KR        Windows-874    Windows-1257
    ISO-8859-5   EUC-CN        Windows-1250   Windows-1258

=item -H I<headerline>

Specifies a line to add to the mail header. This option can be used
multiple times. Do not end the line with a newline character.

=item -I

This option is nearly identical to B<-i>, but uses the "old" behavior,
which is to include a filename for all MIME parts, even those that are
attached using C<Content-Disposition: inline>.

B<Warning>: not all e-mail clients support this.  This option is
provided only for backward-compatibility.  The use of this option
is therefore discouraged; use B<-i> instead.

=item -M I<mime-type>

Specifies the MIME type to be used for the following file. If not
specified, the MIME type is inferred from the filename extension.

The encoding is determined from the MIME type.

=item -R I<addr1>[,I<addr2...>]

Specify Reply-To: addresses for the e-mail. See B<-r> for allowed formats.

=item -a

Use I<multipart/alternative> for the mail message instead of the default
I<multipart/mixed>.  All message parts will automatically be included
with C<Content-Disposition: inline>, regardless of any B<-i> option.
Note that the simplest representation of the mail (probably I<text/plain>)
should be attached first.

=item -b I<addr1>[,I<addr2...>]

Specify Bcc: addresses for the e-mail. See B<-r> for allowed formats.

=item -c I<addr1>[,I<addr2...>]

Specify Cc: addresses for the e-mail. See B<-r> for allowed formats.

=item -d

For debugging purposes only. The composed mail will be printed on I<stdout>
instead of actually being sent. This option takes precedence over the
MAILATT_DEBUG variable (see below).

=item -f I<addr1>

Specify From: address for the e-mail.

=item -h

Print help (usage information) and exit.

=item -i

Specifies that the first file on the commandline must be forcibly included
with a C<Content-Disposition: inline> header, and without a filename.
If this option is not specified, all parts of the message will be included
with C<Content-Disposition: attachment> and a specified filename.

The option B<-a> takes precedence over B<-i>.

=item -m

This option may be used multiple times, and in any position on the commandline.
It indicates that B<base64> should be used as Content-Transfer-Encoding
for all subsequent attachments and header lines.  This is the default
if unspecified.

This option is called B<-m> as a reference to mmencode(1). However,
B<mailatt> does not require any external mmencode(1) program.

See also B<-q>.

=item -q

This option may be used multiple times, and in any position on the commandline.
It indicates that B<quoted-printable> should be used as Content-Transfer-Encoding
for all subsequent attachments and header lines.

Although quoted-printable is normally only used for ASCII attachments,
B<mailatt> also supports this encoding for binaries.

See also B<-m>.

=item -r I<addr1>[,I<addr2...>]

Specify recipients (To: addresses) for the e-mail.

Each one of the addresses may be specified in one of the following
formats:

=over 4

=over

=item I<user>

=item <I<user>>

=item <I<user>@I<domain>>

=item I<name> <I<user>>

=item I<name> <I<user>@I<domain>>

=back

=back

The first two forms will be expanded (using the system F<passwd> file or (if
configured) the NIS F<passwd> map) to the form "I<name>S< ><I<user>>", which
the mailer system may further expand to "I<name>S< ><I<user>@I<domain>>".

The B<-r> option is strictly speaking not mandatory for B<mailatt>, but it
is for programs like sendmail(1).

=item -s I<subject>

Specify subject for the e-mail.

=item -u

This option may be used multiple times, and in any position on the commandline.
It indicates that B<uuencode> should be used as Content-Transfer-Encoding
for all subsequent attachments (header lines will be base64-encoded).

B<Warning>: not all e-mail clients support this.  The use of this option
is therefore discouraged; use B<-m> instead.

See also B<-m> and B<-q>.

=item -v

Display version information and exit.

=item I<file1> [ I<file2>... ]

Indicate which files should be attached to the mail.  Depending on the
"extension" (I<i.e.> the filename part following a C<.> in the filename),
a corresponding MIME type will be selected from a built-in list.

If the file type is not known or the extension is empty, the file will be
sent as type I<application/octet-stream>, unless the B<-a> or B<-i>
option requires it to be included inline.  In that case, the MIME type
will forcibly be changed to I<text/plain>.

At most one of the filenames may be specified as a single C<-> (minus),
which will cause B<mailatt> to read a document from stdin. If entered
interactively, such a document should be ended with the I<eof>-character
(usually CTRL-D). B<mailatt> will always assume that this document is of
type I<text/plain>.

=back

=head1 EXAMPLES

Send all F<*.eps> files to two recipients:

  mailatt -s'Filesystem usage' -r alexander,maxima fsgraph-*.eps

Send a file fragment, carbon copy to the sysadmin (possibly forwarded by
a F<.forward> file):

  mailatt -s'Fragment 2/10' -r beatrix -c root dumps.tar.gz.xab

Send a formatted file, preceded by an introductory message, typed
interactively:

  mailatt -s'Sendmail manual' -r sysadmin@domain.nl -i - sendmail.pdf
  Hello Bernhard,
  Here is the sendmail manual I promised.
  ^D

Send a formatted mail in HTML format, specifying a From: address:

  mailatt -f 'Pieter <pvvollenhoven@hotmail.com>' -r margriet
          -i birthdaycard.html

Send a mail in both plain text and HTML format:

  mailatt -a -r constantijn,friso -s greeting.txt greeting.html

Attach a file of unknown MIME type using quoted-printable encoding (I<e.g.>
to increase readability).  This overrules the default encoding (base64)
that is used for attachments of unknown MIME type coming I<before> the
B<-q> option.

  mailatt -r christina -s "config files" -i body.txt
          /etc/sendmail.cf -q /etc/hosts

Send a mail using the Cyrillic character set to multiple addresses:

  mailatt -r 'Mr. Putin <putin@kremlin.ru>,root'
          -s 'Important letter' -i -C ISO-8859-5 letter.txt

Add custom lines to the mail header:

  mailatt -r 'Benedictus_XVI@vatican.va' -s 'Oldest translation'
          -i -H "X-Year-Finished: 1637" message.txt SV.pdf

Add a Sender: line to the mail header:

  mailatt -r all@company.com -s 'Important announcement' -i
          -H 'Sender: secretary@company.com' -f ceo@company.com
	  message.html

Send a mail with mixed character sets:

=for roff
.PP
.Vb 2
.ie \n(.g \{\
\&  mailatt -C ISO-8859-15 -r 'Fran\(,cois <francois@nimporte.ou>'
\&          -s 'All\(^o' -C UTF-8 -i message.html -C windows-1253 m.txt
.\}
.el \{\
\&  mailatt -C ISO-8859-15 -r 'Franc\*,ois <francois@nimporte.ou>'
\&          -s 'Allo\*^' -C UTF-8 -i message.html -C windows-1253 m.txt
.\}
.Ve
.PP

Send a mail with specified MIME types:

  mailatt -r amalia -i greeting.txt
          -M application/x-rpm mailcap-2.1.31.noarch.rpm
          -M audio/x-pn-realaudio recording.rpm

Specify the MIME type of an attachment fed via stdin:

  mailatt -r alexia -s 'Holiday pictures' -i -C ISO-Latin-15
          -M text/html - skiing-1.jpg skiing-2.jpg < greeting.html

=head1 ENVIRONMENT

=over 4

=item MAILATT_DEBUG

For debugging purposes only. If set and not B<0>, causes the composed mail
to be printed on I<stdout> instead of actually being sent.

=back

=head1 BUGS and WARNINGS

If a file is included using input redirection, its MIME type will be inferred
to be I<text/plain> unless a different type is specified on the command line
using the B<-M> option.

RFC 5322 requires the message body to be sent with network style (CR/LF) line
endings.  This means that ASCII files with Un*x style (LF) line endings need
to be attached using quoted-printable encoding if you want the line endings to
be preserved.  For the time being, this means that you will have to specify a
non-US-ASCII characterset.

=head1 SEE ALSO

base64(1), mail(1), mailx(1), mmencode(1), sendmail(8), uuencode(1).

=over 10

=item RFC 822:

Format of Internet Text Messages

=item RFC 1049:

The Content-Type Header Field for Internet Messages

=item RFC 2045:

MIME: Format of Internet Message Bodies

=item RFC 2046:

MIME: Media Types

=item RFC 2047:

MIME: Message Header Extensions for Non-ASCII Text

=item RFC 2183:

The Content-Disposition Header Field

=item RFC 2387:

The multipart/related Content-Type

=item RFC 2392:

Content-ID and Message-ID URLs

=item RFC 2822:

Internet Message Format

=item RFC 4648:

The Base16, Base32, and Base64 Data Encodings

=item RFC 5322:

Internet Message Format

=for author only: RFC 1521: MIME Part One: Mechanisms for Specifying and Describing
the Format of Internet Message Bodies

=for author only: RFC 1522: MIME Part Two: Message Header Extensions for Non-ASCII Text

=for author only: RFC 2646: The text/plain Format parameter

=for author only: RFC 4021: Registration of Mail and MIME Header Fields

=for author only: Character sets: https://www.iana.org/assignments/character-sets/character-sets.xhtml

=for author only: Character sets: http://nixnik.50webs.com/lynx/lynx_cfg.d/character_sets.html

=for author only: Character sets: https://www.ibm.com/support/knowledgecenter/en/SSVRGU_10.0.1/basic/LSAZ_APPENDIX_E_MIME_CHARSET_NAMES.html

=back

=head1 VERSION

=for roff
.PP \" display the 'pertains to'-macro
.Vp \*(Vw

=head1 AUTHOR and COPYRIGHT

=for roff
.\" the \(co macro only exists in groff
.ie \n(.g Copyright \(co \*(Yr, Ren\('e
.el       Copyright (c) \*(Yr, Rene\*'
Uittenbogaard (ruittenb@users.sourceforge.net)

This program is free software; you can redistribute it and/or modify it
under the terms described by the GNU General Public License version 3.

C<mailatt> is distributed without any warranty, even without the
implied warranties of merchantability or fitness for a particular purpose.

=cut

